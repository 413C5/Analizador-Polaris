package proyecto1;

/* ProyectoParcial1.java */
 /* Generated By:JavaCC: Do not edit this line. ProyectoParcial1.java */
import java.util.ArrayList;
import syntaxtree.*;
import java.util.Vector;

public class ProyectoParcial1 implements ProyectoParcial1Constants {

    ArrayList<Token> lista;
    ArrayList<Simbolo> tabla;
    Simbolo sim;

    final public Programa Programa() throws ParseException {
        NodeList n0 = new NodeList();
        Sentencia n1;
        label_1:
        while (true) {
            n1 = Sentencia();
            n0.addNode(n1);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ENTERO:
                case FLOTANTE:
                case STRING:
                case LECTURA:
                case IMPRIMIR:
                case IF:
                case FOR:
                case WHILE:
                case VARIABLE: {
                    ;
                    break;
                }
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
        }
        n0.nodes.trimToSize();
        {
            if ("" != null) {
                return new Programa(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Sentencia Sentencia() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        DeclararVariable n2;
        NodeToken n3;
        Token n4;
        NodeSequence n5;
        SentenciaLeer n6;
        NodeToken n7;
        Token n8;
        NodeSequence n9;
        SentenciaImprimir n10;
        NodeToken n11;
        Token n12;
        NodeSequence n13;
        AsignarValor n14;
        NodeToken n15;
        Token n16;
        SentenciaIf n17;
        SentenciaFor n18;
        SentenciaWhile n19;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case ENTERO:
            case FLOTANTE:
            case STRING: {
                n1 = new NodeSequence(2);
                n2 = DeclararVariable();
                n1.addNode(n2);
                n4 = jj_consume_token(PUNTO_COMA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n1.addNode(n3);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case LECTURA: {
                n5 = new NodeSequence(2);
                n6 = SentenciaLeer();
                n5.addNode(n6);
                n8 = jj_consume_token(PUNTO_COMA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n7 = JTBToolkit.makeNodeToken(n8);
                n5.addNode(n7);
                n0 = new NodeChoice(n5, 1);
                break;
            }
            case IMPRIMIR: {
                n9 = new NodeSequence(2);
                n10 = SentenciaImprimir();
                n9.addNode(n10);
                n12 = jj_consume_token(PUNTO_COMA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n11 = JTBToolkit.makeNodeToken(n12);
                n9.addNode(n11);
                n0 = new NodeChoice(n9, 2);
                break;
            }
            case VARIABLE: {
                n13 = new NodeSequence(2);
                n14 = AsignarValor();
                n13.addNode(n14);
                n16 = jj_consume_token(PUNTO_COMA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n15 = JTBToolkit.makeNodeToken(n16);
                n13.addNode(n15);
                n0 = new NodeChoice(n13, 3);
                break;
            }
            case IF: {
                n17 = SentenciaIf();
                n0 = new NodeChoice(n17, 4);
                break;
            }
            case FOR: {
                n18 = SentenciaFor();
                n0 = new NodeChoice(n18, 5);
                break;
            }
            case WHILE: {
                n19 = SentenciaWhile();
                n0 = new NodeChoice(n19, 6);
                break;
            }
            default:
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new Sentencia(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public DeclararVariable DeclararVariable() throws ParseException {
        TipoDato n0;
        NodeToken n1;
        Token n2;
        n0 = TipoDato();
        n2 = jj_consume_token(VARIABLE);
        System.out.println("Token:" + token.toString());
        
        
        if (lista != null) {
            lista.add(token);
            sim.nombre=token.toString();
            if(tabla.contains(sim)){
                throw new ArithmeticException(" Variable "+
                        sim.nombre+" ya declarada,Linea "+token.beginLine);
            }
            else{
                tabla.add(sim);
            }
        }
        
        
        n1 = JTBToolkit.makeNodeToken(n2);
        {
            if ("" != null) {
                return new DeclararVariable(n0, n1);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public TipoDato TipoDato() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case ENTERO: {
                n2 = jj_consume_token(ENTERO);
                System.out.println("Token:" + token.toString());
                
                
                if (lista != null) {
                    lista.add(token);
                    sim=new Simbolo();
                    sim.tipo=token.toString();
                }
                
                
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case FLOTANTE: {
                n4 = jj_consume_token(FLOTANTE);
                System.out.println("Token:" + token.toString());
                
                
                if (lista != null) {
                    lista.add(token);
                    sim=new Simbolo();
                    sim.tipo=token.toString();
                }
                
                
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            case STRING: {
                n6 = jj_consume_token(STRING);
                System.out.println("Token:" + token.toString());
                
                
                if (lista != null) {
                    lista.add(token);
                    sim=new Simbolo();
                    sim.tipo=token.toString();
                }
                
                
                n5 = JTBToolkit.makeNodeToken(n6);
                n0 = new NodeChoice(n5, 2);
                break;
            }
            default:
                jj_la1[2] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new TipoDato(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public SentenciaLeer SentenciaLeer() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        NodeToken n4;
        Token n5;
        NodeToken n6;
        Token n7;
        n1 = jj_consume_token(LECTURA);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(PAR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        n5 = jj_consume_token(VARIABLE);
        System.out.println("Token:" + token.toString());
        
        
        //Verificar si ID esta en la tabla de simbolos
        Simbolo t=new Simbolo();
        t.nombre=token.toString();
        if(!tabla.contains(t)){
            throw new ArithmeticException(" READLN,variable "
                    +t.nombre+" no declarada,Linea"+token.beginLine);
        }
        
        
        if (lista != null) {
            lista.add(token);
        }
        n4 = JTBToolkit.makeNodeToken(n5);
        n7 = jj_consume_token(PAR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n6 = JTBToolkit.makeNodeToken(n7);
        {
            if ("" != null) {
                return new SentenciaLeer(n0, n2, n4, n6);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public SentenciaImprimir SentenciaImprimir() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        Expresion n4;
        NodeToken n5;
        Token n6;
        n1 = jj_consume_token(IMPRIMIR);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(PAR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        n4 = Expresion();
        n6 = jj_consume_token(PAR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n5 = JTBToolkit.makeNodeToken(n6);
        {
            if ("" != null) {
                return new SentenciaImprimir(n0, n2, n4, n5);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public AsignarValor AsignarValor() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        Expresion n4;
        n1 = jj_consume_token(VARIABLE);
        
        
        //Verificar si ID esta en la tabla de simbolos
        Simbolo t=new Simbolo();
        t.nombre=token.toString();
        if(!tabla.contains(t)){
            throw new ArithmeticException(" ASIGNARVALOR,variable "
                    +t.nombre+" no declarada,Linea"+token.beginLine);
        }
        
        
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(ASIGNACION);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        n4 = Expresion();
        {
            if ("" != null) {
                return new AsignarValor(n0, n2, n4);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Expresion Expresion() throws ParseException {
        ExpresionSimple n0;
        NodeOptional n1 = new NodeOptional();
        NodeSequence n2;
        OperadorComparacion n3;
        ExpresionSimple n4;
        n0 = ExpresionSimple();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case COMPARACION:
            case MENOR_QUE:
            case MAYOR_QUE:
            case MENOR_IGUAL:
            case MAYOR_IGUAL: {
                n2 = new NodeSequence(2);
                n3 = OperadorComparacion();
                n2.addNode(n3);
                n4 = ExpresionSimple();
                n2.addNode(n4);
                n1.addNode(n2);
                break;
            }
            default:
                jj_la1[3] = jj_gen;
                ;
        }
        {
            if ("" != null) {
                return new Expresion(n0, n1);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public OperadorComparacion OperadorComparacion() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        NodeToken n7;
        Token n8;
        NodeToken n9;
        Token n10;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case COMPARACION: {
                n2 = jj_consume_token(COMPARACION);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case MENOR_QUE: {
                n4 = jj_consume_token(MENOR_QUE);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            case MAYOR_QUE: {
                n6 = jj_consume_token(MAYOR_QUE);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n5 = JTBToolkit.makeNodeToken(n6);
                n0 = new NodeChoice(n5, 2);
                break;
            }
            case MENOR_IGUAL: {
                n8 = jj_consume_token(MENOR_IGUAL);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n7 = JTBToolkit.makeNodeToken(n8);
                n0 = new NodeChoice(n7, 3);
                break;
            }
            case MAYOR_IGUAL: {
                n10 = jj_consume_token(MAYOR_IGUAL);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n9 = JTBToolkit.makeNodeToken(n10);
                n0 = new NodeChoice(n9, 4);
                break;
            }
            default:
                jj_la1[4] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new OperadorComparacion(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpresionSimple ExpresionSimple() throws ParseException {
        Termino n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        OperadorTermino n3;
        Termino n4;
        n0 = Termino();
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case SUMA:
                case RESTA: {
                    ;
                    break;
                }
                default:
                    jj_la1[5] = jj_gen;
                    break label_2;
            }
            n2 = new NodeSequence(2);
            n3 = OperadorTermino();
            n2.addNode(n3);
            n4 = Termino();
            n2.addNode(n4);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null) {
                return new ExpresionSimple(n0, n1);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public OperadorTermino OperadorTermino() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case SUMA: {
                n2 = jj_consume_token(SUMA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case RESTA: {
                n4 = jj_consume_token(RESTA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new OperadorTermino(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Termino Termino() throws ParseException {
        Factor n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        OperadorFactor n3;
        Factor n4;
        n0 = Factor();
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case MULTIPLICACION:
                case DIVISION:
                case MODULO: {
                    ;
                    break;
                }
                default:
                    jj_la1[7] = jj_gen;
                    break label_3;
            }
            n2 = new NodeSequence(2);
            n3 = OperadorFactor();
            n2.addNode(n3);
            n4 = Factor();
            n2.addNode(n4);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null) {
                return new Termino(n0, n1);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public OperadorFactor OperadorFactor() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case MULTIPLICACION: {
                n2 = jj_consume_token(MULTIPLICACION);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case DIVISION: {
                n4 = jj_consume_token(DIVISION);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            case MODULO: {
                n6 = jj_consume_token(MODULO);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n5 = JTBToolkit.makeNodeToken(n6);
                n0 = new NodeChoice(n5, 2);
                break;
            }
            default:
                jj_la1[8] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new OperadorFactor(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Factor Factor() throws ParseException {
        Complejo n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        OperadorComplejo n3;
        Complejo n4;
        n0 = Complejo();
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case POTENCIA:
                case RAIZ_CUADRADA: {
                    ;
                    break;
                }
                default:
                    jj_la1[9] = jj_gen;
                    break label_4;
            }
            n2 = new NodeSequence(2);
            n3 = OperadorComplejo();
            n2.addNode(n3);
            n4 = Complejo();
            n2.addNode(n4);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null) {
                return new Factor(n0, n1);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public OperadorComplejo OperadorComplejo() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case POTENCIA: {
                n2 = jj_consume_token(POTENCIA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case RAIZ_CUADRADA: {
                n4 = jj_consume_token(RAIZ_CUADRADA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new OperadorComplejo(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Complejo Complejo() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        NodeToken n2;
        Token n3;
        Expresion n4;
        NodeToken n5;
        Token n6;
        Valor n7;
        NodeToken n8;
        Token n9;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case PAR_IZQ: {
                n1 = new NodeSequence(3);
                n3 = jj_consume_token(PAR_IZQ);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n2 = JTBToolkit.makeNodeToken(n3);
                n1.addNode(n2);
                n4 = Expresion();
                n1.addNode(n4);
                n6 = jj_consume_token(PAR_DER);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n5 = JTBToolkit.makeNodeToken(n6);
                n1.addNode(n5);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case NUM_ENTERO:
            case NUM_FLOTANTE:
            case CADENA: {
                n7 = Valor();
                n0 = new NodeChoice(n7, 1);
                break;
            }
            case VARIABLE: {
                n9 = jj_consume_token(VARIABLE);
                System.out.println("Token:" + token.toString());
                
                
                //Verificar si ID esta en la tabla de simbolos
                Simbolo t=new Simbolo();
                t.nombre=token.toString();
                if(!tabla.contains(t)){
                    throw new ArithmeticException(" COMPLEJO,variable "
                        +t.nombre+" no declarada,Linea"+token.beginLine);
        }
                
                
                if (lista != null) {
                    lista.add(token);
                }
                n8 = JTBToolkit.makeNodeToken(n9);
                n0 = new NodeChoice(n8, 2);
                break;
            }
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new Complejo(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Valor Valor() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case NUM_ENTERO: {
                n2 = jj_consume_token(NUM_ENTERO);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case NUM_FLOTANTE: {
                n4 = jj_consume_token(NUM_FLOTANTE);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            case CADENA: {
                n6 = jj_consume_token(CADENA);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n5 = JTBToolkit.makeNodeToken(n6);
                n0 = new NodeChoice(n5, 2);
                break;
            }
            default:
                jj_la1[12] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new Valor(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public OperadorLogico OperadorLogico() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case AND: {
                n2 = jj_consume_token(AND);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case OR: {
                n4 = jj_consume_token(OR);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            case NOT: {
                n6 = jj_consume_token(NOT);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n5 = JTBToolkit.makeNodeToken(n6);
                n0 = new NodeChoice(n5, 2);
                break;
            }
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new OperadorLogico(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public SentenciaIf SentenciaIf() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        ExpresionCondicional n4;
        NodeToken n5;
        Token n6;
        NodeToken n7;
        Token n8;
        NodeList n9 = new NodeList();
        Sentencia n10;
        NodeToken n11;
        Token n12;
        NodeOptional n13 = new NodeOptional();
        ExpresionElse n14;
        n1 = jj_consume_token(IF);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(PAR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        n4 = ExpresionCondicional();
        n6 = jj_consume_token(PAR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n5 = JTBToolkit.makeNodeToken(n6);
        n8 = jj_consume_token(CUR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n7 = JTBToolkit.makeNodeToken(n8);
        label_5:
        while (true) {
            n10 = Sentencia();
            n9.addNode(n10);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ENTERO:
                case FLOTANTE:
                case STRING:
                case LECTURA:
                case IMPRIMIR:
                case IF:
                case FOR:
                case WHILE:
                case VARIABLE: {
                    ;
                    break;
                }
                default:
                    jj_la1[14] = jj_gen;
                    break label_5;
            }
        }
        n9.nodes.trimToSize();
        n12 = jj_consume_token(CUR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n11 = JTBToolkit.makeNodeToken(n12);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case ELSE: {
                n14 = ExpresionElse();
                n13.addNode(n14);
                break;
            }
            default:
                jj_la1[15] = jj_gen;
                ;
        }
        {
            if ("" != null) {
                return new SentenciaIf(n0, n2, n4, n5, n7, n9, n11, n13);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpresionElse ExpresionElse() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        NodeList n4 = new NodeList();
        Sentencia n5;
        NodeToken n6;
        Token n7;
        n1 = jj_consume_token(ELSE);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(CUR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        label_6:
        while (true) {
            n5 = Sentencia();
            n4.addNode(n5);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ENTERO:
                case FLOTANTE:
                case STRING:
                case LECTURA:
                case IMPRIMIR:
                case IF:
                case FOR:
                case WHILE:
                case VARIABLE: {
                    ;
                    break;
                }
                default:
                    jj_la1[16] = jj_gen;
                    break label_6;
            }
        }
        n4.nodes.trimToSize();
        n7 = jj_consume_token(CUR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n6 = JTBToolkit.makeNodeToken(n7);
        {
            if ("" != null) {
                return new ExpresionElse(n0, n2, n4, n6);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public ExpresionCondicional ExpresionCondicional() throws ParseException {
        Expresion n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        OperadorLogico n3;
        Expresion n4;
        n0 = Expresion();
        label_7:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case AND:
                case OR:
                case NOT: {
                    ;
                    break;
                }
                default:
                    jj_la1[17] = jj_gen;
                    break label_7;
            }
            n2 = new NodeSequence(2);
            n3 = OperadorLogico();
            n2.addNode(n3);
            n4 = Expresion();
            n2.addNode(n4);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null) {
                return new ExpresionCondicional(n0, n1);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public SentenciaFor SentenciaFor() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        NodeToken n4;
        Token n5;
        NodeToken n6;
        Token n7;
        NodeToken n8;
        Token n9;
        NodeToken n10;
        Token n11;
        NodeToken n12;
        Token n13;
        NodeToken n14;
        Token n15;
        OperadorComparacion n16;
        NodeToken n17;
        Token n18;
        NodeToken n19;
        Token n20;
        NodeToken n21;
        Token n22;
        OperadorAumento n23;
        NodeToken n24;
        Token n25;
        NodeToken n26;
        Token n27;
        NodeList n28 = new NodeList();
        Sentencia n29;
        NodeToken n30;
        Token n31;
        n1 = jj_consume_token(FOR);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(PAR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        n5 = jj_consume_token(ENTERO);
        System.out.println("Token:" + token.toString());
        
        if (lista != null) {
            lista.add(token);
        }
        
        n4 = JTBToolkit.makeNodeToken(n5);
        n7 = jj_consume_token(VARIABLE);
        System.out.println("Token:" + token.toString());
        
        
        if (lista != null) {
            lista.add(token);
            sim=new Simbolo();
            sim.tipo="int";
            sim.nombre=token.toString();
            if(tabla.contains(sim)){
                throw new ArithmeticException(" Variable "+
                        sim.nombre+" ya declarada,Linea "+token.beginLine);
            }
            else{
                tabla.add(sim);
            }
        }

        n6 = JTBToolkit.makeNodeToken(n7);
        n9 = jj_consume_token(ASIGNACION);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n8 = JTBToolkit.makeNodeToken(n9);
        n11 = jj_consume_token(NUM_ENTERO);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n10 = JTBToolkit.makeNodeToken(n11);
        n13 = jj_consume_token(PUNTO_COMA);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n12 = JTBToolkit.makeNodeToken(n13);
        n15 = jj_consume_token(VARIABLE);
        System.out.println("Token:" + token.toString());
        
        
        //Verificar si ID esta en la tabla de simbolos
        Simbolo t=new Simbolo();
        t.nombre=token.toString();
        if(!tabla.contains(t)){
            throw new ArithmeticException(" FOR,variable "
                    +t.nombre+" no declarada,Linea"+token.beginLine);
        }
        
        if (lista != null) {
            lista.add(token);
        }
        
        
        n14 = JTBToolkit.makeNodeToken(n15);
        n16 = OperadorComparacion();
        n18 = jj_consume_token(NUM_ENTERO);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n17 = JTBToolkit.makeNodeToken(n18);
        n20 = jj_consume_token(PUNTO_COMA);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n19 = JTBToolkit.makeNodeToken(n20);
        n22 = jj_consume_token(VARIABLE);
        System.out.println("Token:" + token.toString());
        
        //Verificar si ID esta en la tabla de simbolos
        Simbolo t2=new Simbolo();
        t2.nombre=token.toString();
        if(!tabla.contains(t2)){
            throw new ArithmeticException(" FOR,variable "
                    +t.nombre+" no declarada,Linea"+token.beginLine);
        }
        
        if (lista != null) {
            lista.add(token);
        }
        n21 = JTBToolkit.makeNodeToken(n22);
        n23 = OperadorAumento();
        n25 = jj_consume_token(PAR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n24 = JTBToolkit.makeNodeToken(n25);
        n27 = jj_consume_token(CUR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n26 = JTBToolkit.makeNodeToken(n27);
        label_8:
        while (true) {
            n29 = Sentencia();
            n28.addNode(n29);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ENTERO:
                case FLOTANTE:
                case STRING:
                case LECTURA:
                case IMPRIMIR:
                case IF:
                case FOR:
                case WHILE:
                case VARIABLE: {
                    ;
                    break;
                }
                default:
                    jj_la1[18] = jj_gen;
                    break label_8;
            }
        }
        n28.nodes.trimToSize();
        n31 = jj_consume_token(CUR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n30 = JTBToolkit.makeNodeToken(n31);
        {
            if ("" != null) {
                return new SentenciaFor(n0, n2, n4, n6, n8, n10, n12, n14, n16, n17, n19, n21, n23, n24, n26, n28, n30);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public OperadorAumento OperadorAumento() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 49: {
                n2 = jj_consume_token(49);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n1 = JTBToolkit.makeNodeToken(n2);
                n0 = new NodeChoice(n1, 0);
                break;
            }
            case 50: {
                n4 = jj_consume_token(50);
                System.out.println("Token:" + token.toString());
                if (lista != null) {
                    lista.add(token);
                }
                n3 = JTBToolkit.makeNodeToken(n4);
                n0 = new NodeChoice(n3, 1);
                break;
            }
            default:
                jj_la1[19] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if ("" != null) {
                return new OperadorAumento(n0);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public SentenciaWhile SentenciaWhile() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        ExpresionCondicional n4;
        NodeToken n5;
        Token n6;
        NodeToken n7;
        Token n8;
        NodeList n9 = new NodeList();
        Sentencia n10;
        NodeToken n11;
        Token n12;
        n1 = jj_consume_token(WHILE);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(PAR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n2 = JTBToolkit.makeNodeToken(n3);
        n4 = ExpresionCondicional();
        n6 = jj_consume_token(PAR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n5 = JTBToolkit.makeNodeToken(n6);
        n8 = jj_consume_token(CUR_IZQ);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n7 = JTBToolkit.makeNodeToken(n8);
        label_9:
        while (true) {
            n10 = Sentencia();
            n9.addNode(n10);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ENTERO:
                case FLOTANTE:
                case STRING:
                case LECTURA:
                case IMPRIMIR:
                case IF:
                case FOR:
                case WHILE:
                case VARIABLE: {
                    ;
                    break;
                }
                default:
                    jj_la1[20] = jj_gen;
                    break label_9;
            }
        }
        n9.nodes.trimToSize();
        n12 = jj_consume_token(CUR_DER);
        System.out.println("Token:" + token.toString());
        if (lista != null) {
            lista.add(token);
        }
        n11 = JTBToolkit.makeNodeToken(n12);
        {
            if ("" != null) {
                return new SentenciaWhile(n0, n2, n4, n5, n7, n9, n11);
            }
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * Generated Token Manager.
     */
    public ProyectoParcial1TokenManager token_source;
    JavaCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[21];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x4fe, 0x4fe, 0xe, 0xf80000, 0xf80000, 0x3000, 0x3000, 0x1c000, 0x1c000, 0x60000, 0x60000, 0x8000000, 0x0, 0x7000000, 0x4fe, 0x200, 0x4fe, 0x7000000, 0x4fe, 0x0, 0x4fe,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x138, 0x130, 0x0, 0x8, 0x0, 0x8, 0x0, 0x8, 0x60000, 0x8,};
    }

    /**
     * Constructor with InputStream.
     */
    public ProyectoParcial1(java.io.InputStream stream) {
        this(stream, null);
        lista = null;
        tabla=null;
    }

    //Constructor con ArrayList
    public ProyectoParcial1(ArrayList<Token> lista, java.io.InputStream stream) {
        this(stream, null);
        this.lista = lista;
    }
    
    //Constructor con 2 arrayList
    public ProyectoParcial1(ArrayList<Token> lista,ArrayList<Simbolo> tabla, java.io.InputStream stream) {
        this(stream, null);
        this.lista = lista;
        this.tabla=tabla;
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public ProyectoParcial1(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new ProyectoParcial1TokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Constructor.
     */
    public ProyectoParcial1(java.io.Reader stream) {
        jj_input_stream = new JavaCharStream(stream, 1, 1);
        token_source = new ProyectoParcial1TokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        if (jj_input_stream == null) {
            jj_input_stream = new JavaCharStream(stream, 1, 1);
        } else {
            jj_input_stream.ReInit(stream, 1, 1);
        }
        if (token_source == null) {
            token_source = new ProyectoParcial1TokenManager(jj_input_stream);
        }

        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Constructor with generated Token Manager.
     */
    public ProyectoParcial1(ProyectoParcial1TokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Reinitialise.
     */
    public void ReInit(ProyectoParcial1TokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) {
                t = t.next;
            } else {
                t = t.next = token_source.getNextToken();
            }
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null) {
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        } else {
            return (jj_ntk = jj_nt.kind);
        }
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[51];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 21; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 51; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private boolean trace_enabled;

    /**
     * Trace enabled.
     */
    final public boolean trace_enabled() {
        return trace_enabled;
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

}

class JTBToolkit {

    static NodeToken makeNodeToken(Token t) {
        return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
    }
}
